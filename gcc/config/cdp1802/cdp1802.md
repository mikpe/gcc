;; Machine description for the RCA CDP1802 processor.
;; Copyright (C) 2024 Free Software Foundation, Inc.
;; Contributed by Mikael Pettersson <mikpelinux@gmail.com>.
;;
;; This file is part of GCC.
;;
;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.
;;
;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; Constraints
;; a  r7 (first argument register)
;; b  r8 (second argument register)
;; c  any general-purpose register except SP
;; z  r6 (static chain register)
;; I  an integer constant between -7 and 7
;; Q  pre-dec stack (push)
;; R  post-inc stack (pop)
;; S  post-inc mem
;; T  post-dec mem
;; Z  0

(define_constants
  [
    (SP_REG 2)
    ;(D_REG 16)
    ;(CARRY_REG 17)
    ;(X_REG 18)
  ])

;; ::::::::::::::::::::
;; ::
;; :: Attributes
;; ::
;; ::::::::::::::::::::

(define_attr "length" "" (const_int 1))

(define_asm_attributes [(set_attr "length" "5")])

(include "predicates.md")
(include "constraints.md")

;; TODO: we should add a full complement of QImode insns

;; The ABI guarantees that X=2 (SP) when a function is called, or when
;; a called function returns.  To exploit this the compiler treats X=2
;; as a global invariant, which allows it to skip generating code to set
;; X=2 before accessing the stack.

;; ::::::::::::::::::::
;; ::
;; :: Push / Pop
;; ::
;; ::::::::::::::::::::
;;
;; push/pop qi and hi are here as separate insns rather than part of
;; the movqi/hi patterns because we need to ensure that reload isn't
;; passed anything it can't cope with.  Without these patterns, we
;; might end up with
;;
;; (set (mem (post_inc (sp))) mem (post_inc (reg)))
;;
;; If, in this example, reg needs reloading, reload will read reg from
;; the stack , adjust sp, and store reg back at what is now the wrong
;; offset.  By using separate patterns for push and pop we ensure that
;; insns like this one are never generated.

(define_insn "pushqi1"
  [(set (mem:QI (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:QI 0 "register_operand" "r"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %0\n\tstxd"
  [(set_attr "length" "2")])

(define_insn "popqi1"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(mem:QI (post_inc:HI (reg:HI SP_REG))))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "lda 2\n\tplo %0"
  [(set_attr "length" "2")])

(define_insn "pushhi1"
  [(set (mem:HI (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:HI 0 "register_operand" "c"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %0\n\tstxd\n\tghi %0\n\tstxd"
  [(set_attr "length" "4")])

(define_insn "pophi1"
  [(set (match_operand:HI 0 "register_operand" "=&c")
	(mem:HI (post_inc:HI (reg:HI SP_REG))))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "lda 2\n\tphi %0\n\tlda 2\n\tplo %0"
  [(set_attr "length" "4")])

;; We must provide multi-word push isnsn to prevent emit_move_resolve_push
;; from emitting bogus code for multi-word parameters.
;;
;; emit_move_resolve_push allocates the stack space fine, but sets up the
;; destination for the NON auto-decrement moves at the wrong end of that space,
;; clobbering the area above it.  It also ignores STACK_POINTER_OFFSET.

(define_insn "pushsi1"
  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:SI 0 "register_operand" "r"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %N0\n\tstxd\n\tghi %N0\n\tstxd\n\tglo %0\n\tstxd\n\tghi %0\n\tstxd"
  [(set_attr "length" "8")])

(define_insn "pushsf1"
  [(set (mem:SF (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:SF 0 "register_operand" "r"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %N0\n\tstxd\n\tghi %N0\n\tstxd\n\tglo %0\n\tstxd\n\tghi %0\n\tstxd"
  [(set_attr "length" "8")])


(define_insn "pushdi1"
  [(set (mem:DI (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:DI 0 "nonmemory_operand" "r,i"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   glo %Q0\n\tstxd\n\tghi %Q0\n\tstxd\n\tglo %P0\n\tstxd\n\tghi %P0\n\tstxd\n\tglo %N0\n\tstxd\n\tghi %N0\n\tstxd\n\tglo %0\n\tstxd\n\tghi %0\n\tstxd
   ldi %L0\n\tstxd\n\tldi %H0\n\tstxd\n\tldi %G0\n\tstxd\n\tldi %F0\n\tstxd\n\tldi %E0\n\tstxd\n\tldi %D0\n\tstxd\n\tldi %B0\n\tstxd\n\tldi %A0\n\tstxd"
  [(set_attr_alternative "length"
    [(const_int 16)
     (const_int 24)
    ])
  ])

(define_insn "pushdf1"
  [(set (mem:DF (pre_dec:HI (reg:HI SP_REG)))
	(match_operand:DF 0 "register_operand" "r"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %Q0\n\tstxd\n\tghi %Q0\n\tstxd\n\tglo %P0\n\tstxd\n\tghi %P0\n\tstxd\n\tglo %N0\n\tstxd\n\tghi %N0\n\tstxd\n\tglo %0\n\tstxd\n\tghi %0\n\tstxd"
  [(set_attr "length" "16")])

;; ::::::::::::::::::::
;; ::
;; :: Moves
;; ::
;; ::::::::::::::::::::

;; Note: There are cases, such as testsuite/gcc.dg/compat/scalar-by-value-4_x.c,
;; where gcc generates pushes but using the mov optab instead of the push one.
;; That forces us to recognize them here too.
;; Note 2: GCC generates moves with post-increment memory destinations, even
;; though we define USE_STORE_POST_INCREMENT(MODE) to 0.  To avoid wrong code
;; we must handle them here.

;;; needed by zero_call_used_regs
;(define_insn "movbi"
;  [(set (reg:BI CARRY_REG)
;        (match_operand:BI 0 "immediate_operand" "i"))]
;  ""
;  "ldi %0\n\tshr"
;  [(set_attr "length" "3")])

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(match_operand:QI 1 "general_operand" ""))
  ])

(define_insn "movqi_internal"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,Q,Q,S,S,T,T,m,m,r,r,r,r")
	(match_operand:QI 1 "general_operand"       "r,i,r,i,r,i,r,r,i,S,T,m,i"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   glo %1\n\tplo %0
   ldi %L1\n\tstxd
   glo %1\n\tstxd
   ldi %L1\n\tstr %M0\n\tinc %M0
   glo %1\n\tstr %M0\n\tinc %M0
   ldi %L1\n\tstr %M0\n\tdec %M0
   glo %1\n\tstr %M0\n\tdec %M0
   glo %1\n\tstr %M0
   ldi %L1\n\tstr %M0
   lda %M1\n\tplo %0	/* r0 is fixed so should never be %M1 here */
   ldn %M1\n\tdec %M1\n\tplo %0
   ldn %M1\n\tplo %0
   ldi %1\n\tplo %0"
  [(set_attr_alternative "length"
     [(const_int 2)
      (const_int 3)
      (const_int 2)
      (const_int 4)
      (const_int 3)
      (const_int 4)
      (const_int 3)
      (const_int 2)
      (const_int 3)
      (const_int 2)
      (const_int 3)
      (const_int 2)
      (const_int 3)
     ])
  ])

(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
	(match_operand:HI 1 "general_operand" ""))
  ])

(define_insn "movhi_internal"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,Q,Q,S,S,T,T,m,m,&r,&r,&r,r")
	(match_operand:HI 1 "general_operand"       "r,i,c,i,r,i,r,r,i,S,T,m,i"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   ghi %1\n\tphi %0\n\tglo %1\n\tplo %0
   ldi %L1\n\tstxd\n\tldi %H1\n\tstxd
   glo %1\n\tstxd\n\tghi %1\n\tstxd
   ldi %H1\n\tstr %M0\n\tinc %M0\n\tldi %L1\n\tstr %M0\n\tinc %M0
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0 /* FIXME: %M0 and %1 must not be the same reg */
   ldi %H1\n\tstr %M0\n\tinc %M0\n\tldi %L1\n\tstr %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0
   ghi %1\n\tstr %M0\n\tglo %1\n\tinc %M0\n\tstr %M0\n\tdec %M0
   ldi %H1\n\tstr %M0\n\tinc %M0\n\tldi %L1\n\tstr %M0\n\tdec %M0
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0		/* r0 is fixed so should never be %M1 here */
   lda %M1\n\tphi %0\n\tldn %M1\n\tplo %0\n\tdec %M1\n\tdec %M1\n\tdec %M1	/* r0 is fixed so should never be %M1 here */
   lda %M1\n\tphi %0\n\tldn %M1\n\tplo %0\n\tdec %M1	/* r0 is fixed so should never be %M1 here */
   ldi %H1\n\tphi %0\n\tldi %L1\n\tplo %0"
  [(set_attr_alternative "length"
     [(const_int 4)
      (const_int 6)
      (const_int 4)
      (const_int 8)
      (const_int 6)
      (const_int 10)
      (const_int 8)
      (const_int 6)
      (const_int 8)
      (const_int 4)
      (const_int 7)
      (const_int 5)
      (const_int 6)
     ])
  ])

(define_expand "movsf"
  [(set (match_operand:SF 0 "nonimmediate_operand" "")
	(match_operand:SF 1 "general_operand" ""))
  ])

(define_insn "movsf_internal"
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,Q,S,T,m,&r,&r,&r")
	(match_operand:SF 1 "general_operand"       "r,c,r,r,r,S,T,m"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   * return cdp1802_template_movsf_r_r (operands[0], operands[1]);
   glo %N1\n\tstxd\n\tghi %N1\n\tstxd\n\tglo %1\n\tstxd\n\tghi %1\n\tstxd
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tinc %M0 /* FIXME: %M0 and %1 must not be the same reg */
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0 /* FIXME: %M0 and %1 must not be the same reg */
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0 /* FIXME: %M0 and %1 must not be the same reg */
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tlda %M1\n\tplo %N0
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tldn %M1\n\tplo %N0\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tldn %M1\n\tplo %N0\n\tdec %M1\n\tdec %M1\n\tdec %M1"
  [(set_attr_alternative "length"
     [(const_int 8)
      (const_int 8)
      (const_int 12)
      (const_int 18)
      (const_int 14)
      (const_int 8)
      (const_int 15)
      (const_int 11)
     ])
  ])

(define_expand "movdf"
  [(set (match_operand:DF 0 "nonimmediate_operand" "")
	(match_operand:DF 1 "general_operand" ""))
  ])

(define_insn "movdf_internal"
  [(set (match_operand:DF 0 "nonimmediate_operand" "=r,Q,S,T,m,&r,&r,&r")
	(match_operand:DF 1 "general_operand"       "r,c,r,r,r,S,T,m"))
   ;(clobber (reg:QI D_REG))
   ;(clobber (reg:BI CARRY_REG))
  ]
  ""
  "@
   * return cdp1802_template_movdf_r_r (operands[0], operands[1]);
   glo %Q1\n\tstxd\n\tghi %Q1\n\tstxd\n\tglo %P1\n\tstxd\n\tghi %P1\n\tstxd\n\tglo %N1\n\tstxd\n\tghi %N1\n\tstxd\n\tglo %1\n\tstxd\n\tghi %1\n\tstxd
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tinc %M0\n\tghi %P1\n\tstr %M0\n\tinc %M0\n\tglo %P1\n\tstr %M0\n\tinc %M0\n\tghi %Q1\n\tstr %M0\n\tinc %M0\n\tglo %Q1\n\tstr %M0\n\tinc %M0 /* FIXME: %M0 and %1 must not be the same reg */
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tinc %M0\n\tghi %P1\n\tstr %M0\n\tinc %M0\n\tglo %P1\n\tstr %M0\n\tinc %M0\n\tghi %Q1\n\tstr %M0\n\tinc %M0\n\tglo %Q1\n\tstr %M0\n\tglo %M0\n\tsmi 15\n\tplo %M0\n\tghi %M0\n\tsmbi 0\n\tphi %M0 /* FIXME: %M0 and %1 must not be the same reg */
   ghi %1\n\tstr %M0\n\tinc %M0\n\tglo %1\n\tstr %M0\n\tinc %M0\n\tghi %N1\n\tstr %M0\n\tinc %M0\n\tglo %N1\n\tstr %M0\n\tinc %M0\n\tghi %P1\n\tstr %M0\n\tinc %M0\n\tglo %P1\n\tstr %M0\n\tinc %M0\n\tghi %Q1\n\tstr %M0\n\tinc %M0\n\tglo %Q1\n\tstr %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0\n\tdec %M0 /* FIXME: %M0 and %1 must not be the same reg */
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tlda %M1\n\tplo %N0\n\tlda %M1\n\tphi %P0\n\tlda %M1\n\tplo %P0\n\tlda %M1\n\tphi %Q0\n\tlda %M1\n\tplo %Q0
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tlda %M1\n\tplo %N0\n\tlda %M1\n\tphi %P0\n\tlda %M1\n\tplo %P0\n\tlda %M1\n\tphi %Q0\n\tldn %M1\n\tplo %Q0\n\tglo %M1\n\tsmi 15\n\tplo %M1\n\tghi %M1\n\tsmbi 0\n\tphi %M1
   lda %M1\n\tphi %0\n\tlda %M1\n\tplo %0\n\tlda %M1\n\tphi %N0\n\tlda %M1\n\tplo %N0\n\tlda %M1\n\tphi %P0\n\tlda %M1\n\tplo %P0\n\tlda %M1\n\tphi %Q0\n\tldn %M1\n\tplo %Q0\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1\n\tdec %M1"
  [(set_attr_alternative "length"
     [(const_int 16)
      (const_int 16)
      (const_int 24)
      (const_int 31)
      (const_int 30)
      (const_int 16)
      (const_int 24)
      (const_int 23)
     ])
  ])

;; ::::::::::::::::::::
;; ::
;; :: Conversions
;; ::
;; ::::::::::::::::::::

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI                 0 "register_operand" 	   "=r,r,r")
	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand"  "S,m,0")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   lda %M1\n\tplo %0\n\tldi 0\n\tphi %0
   ldn %M1\n\tplo %0\n\tldi 0\n\tphi %0
   ldi 0\n\tphi %0"
  [(set_attr_alternative "length"
     [(const_int 5)
      (const_int 5)
      (const_int 3)
     ])])

;; ::::::::::::::::::::
;; ::
;; :: 16-bit Integer arithmetic
;; ::
;; ::::::::::::::::::::

;; Addition

;; Note: uses MEM[SP] as a temp
(define_insn "addhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,c,r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0")
		 (match_operand:HI 2 "nonmemory_operand" "I,r,i")))
   ;(clobber (reg:BI CARRY_REG))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   * return cdp1802_template_incdec (true, operands[2]);
   glo %2\n\tstr 2\n\tglo %1\n\tadd\n\tplo %0\n\tghi %2\n\tstr 2\n\tghi %1\n\tadc\n\tphi %0
   glo %1\n\tadi %L2\n\tplo %0\n\tghi %1\n\tadci %H2\n\tphi %0"
  [(set_attr_alternative "length"
     [(symbol_ref "abs (INTVAL (operands[2]))")
      (const_int 10)
      (const_int 8)
     ])
  ])

;;; Since addhi3 clobbers the carry, we MUST provide a non-clobbering addptrhi3
;;; for LRA to use when legitimizing addresses.
;;; Note: uses MEM[SP] as a temp
;(define_insn "addptrhi3"
;  [(set (match_operand:HI 0 "register_operand" "=r,c")
;        (plus:HI (match_operand:HI 1 "register_operand" "0,r")
;	         (match_operand:HI 2 "immediate_operand" "I,i")))
;   ;(clobber (reg:QI D_REG))
;  ]
;  ""
;  "@
;   * return cdp1802_template_incdec (true, operands[2]);
;   shlc\n\tstr 2\n\tglo %1\n\tadi %L2\n\tplo %0\n\tghi %1\n\tadci %H2\n\tphi %0\n\tldn 2\n\tshr"
;  [(set_attr_alternative "length"
;    [(symbol_ref "abs (INTVAL (operands[2]))")
;     (const_int 12)
;    ])
;  ])

;; Subtraction

;; Note: uses MEM[SP] as a temp
;; TODO: add support for (set reg (minus imm reg))
(define_insn "subhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,c,r")
	(minus:HI (match_operand:HI 1 "register_operand" "0,0,0")
		  (match_operand:HI 2 "nonmemory_operand" "I,r,i")))
   ;(clobber (reg:BI CARRY_REG))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   * return cdp1802_template_incdec (false, operands[2]);
   glo %2\n\tstr 2\n\tglo %1\n\tsm\n\tplo %0\n\tghi %2\n\tstr 2\n\tghi %1\n\tsmb\n\tphi %0
   glo %1\n\tsmi %L2\n\tplo %0\n\tghi %1\n\tsmbi %H2\n\tphi %0"
  [(set_attr_alternative "length"
     [(symbol_ref "abs (INTVAL (operands[2]))")
      (const_int 10)
      (const_int 8)
     ])
  ])

;; Negation

;; Note: to avoid clobbering the carry we could compute (~%1) + 1,
;; but that would require one more instruction.
(define_insn "neghi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(neg:HI (match_operand:HI 1 "register_operand" "r")))
   ;(clobber (reg:BI CARRY_REG))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %1\n\tsdi 0\n\tplo %0\n\tghi %1\n\tsdbi 0\n\tphi %0"
  [(set_attr "length" "8")])

;; ::::::::::::::::::::
;; ::
;; :: 16-bit Integer Shifts
;; ::
;; ::::::::::::::::::::

;; Variable-length shifts and rotates are awkward on this processor,
;; so we instruct the compiler to replace them with calls to routines
;; in libgcc2.

;; Arithmetic Shift Left
(define_expand "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0")
		   (match_operand:HI 2 "nonmemory_operand" "ri")))
  ]
  ""
  {
    if (cdp1802_expand_ashlhi3 (operands[0], operands[1], operands[2]))
      DONE;
    /* internal_debug_bt ("ashlhi3 generated"); */
    FAIL;
  })

(define_insn "ashlhi3_by_8"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0")
		   (const_int 8)))
  ]
  ""
  "glo %1\n\tphi %0\n\tldi 0\n\tplo %0"
  [(set_attr "length" "5")])

;; Arithmetic Shift Right
(define_expand "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0")
		     (match_operand:HI 2 "nonmemory_operand" "ri")))
  ]
  ""
  {
    FAIL;
  })

;; Logical Shift Right
(define_expand "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
		     (match_operand:HI 2 "nonmemory_operand" "ri")))
  ]
  ""
  {
    FAIL;
  })

;; ::::::::::::::::::::
;; ::
;; :: 16-Bit Integer Logical operations
;; ::
;; ::::::::::::::::::::

;; Logical AND, 16-bit integers
;; Note: uses MEM[SP] as a temp
(define_insn "andhi3"
  [(set (match_operand:HI 0 "register_operand" "=c,r")
	(and:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonmemory_operand" "r,i")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   glo %2\n\tstr 2\n\tglo %1\n\tand\n\tplo %0\n\tghi %2\n\tstr 2\n\tghi %1\n\tand\n\tphi %0
   glo %1\n\tani %L2\n\tplo %0\n\tghi %1\n\tani %H2\n\tphi %0"
  [(set_attr "length" "10,8")])

;; Inclusive OR, 16-bit integers
;; Note: uses MEM[SP] as a temp
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "register_operand" "=c,r")
	(ior:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonmemory_operand" "r,i")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   glo %2\n\tstr 2\n\tglo %1\n\tor\n\tplo %0\n\tghi %2\n\tstr 2\n\tghi %1\n\tor\n\tphi %0
   glo %1\n\tori %L2\n\tplo %0\n\tghi %1\n\tori %H2\n\tphi %0"
  [(set_attr "length" "10,8")])

;; Exclusive OR, 16-bit integers
;; Note: uses MEM[SP] as a temp
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=c,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonmemory_operand" "r,i")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "@
   glo %2\n\tstr 2\n\tglo %1\n\txor\n\tplo %0\n\tghi %2\n\tstr 2\n\tghi %1\n\txor\n\tphi %0
   glo %1\n\txri %L2\n\tplo %0\n\tghi %1\n\txri %H2\n\tphi %0"
  [(set_attr "length" "10,8")])

;; One's complement, 16-bit integers
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(not:HI (match_operand:HI 1 "register_operand" "0")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %1\n\txri 0xff\n\tplo %0\n\tghi %1\n\txri 0xff\n\tphi %0"
  [(set_attr "length" "8")])

;; ::::::::::::::::::::
;; ::
;; :: Branches
;; ::
;; ::::::::::::::::::::

(define_expand "cbranchhi4"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
			[(match_operand:HI 1 "register_operand" "a")
			 (match_operand:HI 2 "register_operand" "b")])
		      (label_ref (match_operand 3 "" ""))
		      (pc)))
   ;(clobber (reg:BI CARRY_REG))
  ]
  ""
  {
    cdp1802_expand_cbranchhi4 (GET_CODE (operands[0]), operands[1], operands[2],
			       operands[3]);
    DONE;
  })

;; HImode comparisons become long sequences of code that clobber both D and DF,
;; as well as either an R-register or the top of the stack.  To reduce code size
;; we call routines in libgcc for the actual comparisons.  These routines take
;; two arguments in registers and return a flag in DF.  The NCRT return sequence
;; does not clobber DF.
(define_insn "cbranchhi4_internal"
  [(set (pc)
	(if_then_else (match_operator:HI 0 "comparison_operator"
			[(match_operand:HI 1 "nonmemory_operand" "a")
			 (match_operand:HI 2 "nonmemory_operand" "b")])
		      (label_ref (match_operand 3 "" ""))
		      (pc)))
   ;(clobber (reg:BI CARRY_REG))
  ]
  ""
  "sep 4\n\t.hword __cmphi_%C0\n\tlbdf %3"
  [(set_attr "length" "6")
  ])

;; ::::::::::::::::::::
;; ::
;; :: Calls and jumps
;; ::
;; ::::::::::::::::::::

(define_expand "call"
  [(call (match_operand:QI 0 "memory_operand" "m")
	 (match_operand:HI 1 "const_int_operand" "n"))
   (use (match_operand 2 "immediate_operand" ""))
  ]
  ""
  {
    cdp1802_expand_call (NULL_RTX, operands[0], operands[1]);
    DONE;
  })

(define_expand "sibcall"
  [(call (match_operand:QI 0 "memory_operand" "m")
	 (match_operand:HI 1 "const_int_operand" "n"))
   (use (match_operand 2 "immediate_operand" ""))
  ]
  ""
  {
    cdp1802_expand_call (NULL_RTX, operands[0], operands[1]);
    DONE;
  })

(define_expand "call_value"
  [(set (match_operand 0 "register_operand" "=r")
	(call (match_operand:QI 1 "memory_operand" "m")
	      (match_operand:HI 2 "" "")))
   (use (match_operand 3 "immediate_operand" ""))
  ]
  ""
  {
    cdp1802_expand_call (operands[0], operands[1], operands[2]);
    DONE;
  })

(define_expand "sibcall_value"
  [(set (match_operand 0 "register_operand" "=r")
	(call (match_operand:QI 1 "memory_operand" "m")
	      (match_operand:HI 2 "" "")))
   (use (match_operand 3 "immediate_operand" ""))
  ]
  ""
  {
    cdp1802_expand_call (operands[0], operands[1], operands[2]);
    DONE;
  })

(define_insn "*call_internal"
  [(call (mem:QI (match_operand:HI 0 "nonmemory_operand" "i,r"))
	 (match_operand 1 "" ""))
   (use (match_operand:HI 2 "nonmemory_operand" "X,z"))
  ]
  "!SIBLING_CALL_P (insn)"
  "@
  sep 4\n\t.hword %0
  sep 4\n\t.hword __call_reg"	; actual callee in the static chain register (z-constraint)
  [(set_attr "length" "3,3")])

(define_insn "*sibcall_internal"
  [(call (mem:QI (match_operand:HI 0 "nonmemory_operand" "i,r"))
	 (match_operand 1 "" ""))
   (use (match_operand:HI 2 "nonmemory_operand" "X,z"))
  ]
  "SIBLING_CALL_P (insn)"
  "@
  lbr %0
  lbr __call_reg"	; actual callee in the static chain register (z-constraint)
  [(set_attr "length" "3,3")])

(define_insn "*call_value_internal"
  [(set (match_operand 3 "register_operand" "=r,r")
        (call (mem:QI (match_operand:HI 0 "nonmemory_operand" "i,r"))
	      (match_operand 1 "" "")))
   (use (match_operand:HI 2 "nonmemory_operand" "X,z"))
  ]
  "!SIBLING_CALL_P (insn)"
  "@
  sep 4\n\t.hword %0
  sep 4\n\t.hword __call_reg"	; actual target in the static chain register (z-constraint)
  [(set_attr "length" "3,3")])

(define_insn "*sibcall_value_internal"
  [(set (match_operand 3 "register_operand" "=r,r")
        (call (mem:QI (match_operand:HI 0 "nonmemory_operand" "i,r"))
	      (match_operand 1 "" "")))
   (use (match_operand:HI 2 "nonmemory_operand" "X,z"))
  ]
  "SIBLING_CALL_P (insn)"
  "@
  lbr %0
  lbr __call_reg"	; actual target in the static chain register (z-constraint)
  [(set_attr "length" "3,3")])

;; Subroutine return
(define_expand "return"
  [(return)]
  "cdp1802_direct_return_p ()"
  "")

(define_insn "return_internal"
  [(return)]
  ""
  "sep 5"
  [(set_attr "length" "1")])

;; Normal unconditional jump
(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))]
  ""
  "lbr %l0"
  [(set_attr "length" "3")
  ])

;; Indirect jump through a register
(define_expand "indirect_jump"
  [(set (pc) (match_operand:HI 0 "register_operand" "r"))])

;; Push the target address, then return.
(define_insn "indirect_jump_internal"
  [(set (pc) (match_operand:HI 0 "register_operand" "r"))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %0\n\tstxd\n\tghi %0\n\tstxd\n\tsep 5"
  [(set_attr "length" "5")])

;; Table-based switch statements.
(define_insn "tablejump"
  [(set (pc) (match_operand:HI 0 "register_operand" "r"))
   (use (label_ref:HI (match_operand 1 "" "")))
   ;(clobber (reg:QI D_REG))
  ]
  ""
  "glo %0\n\tstxd\n\tghi %0\n\tstxd\n\tsep 5"
  [(set_attr "length" "5")])

(define_expand "save_stack_nonlocal"
  [(match_operand 0 "memory_operand" "")
   (match_operand 1 "register_operand" "")]
  ""
{
  cdp1802_expand_save_stack_nonlocal (operands[0], operands[1]);
  DONE;
})

(define_expand "restore_stack_nonlocal"
  [(match_operand 0 "register_operand" "")
   (match_operand 1 "memory_operand" "")]
  ""
{
  cdp1802_expand_restore_stack_nonlocal (operands[0], operands[1]);
  DONE;
})

(define_expand "nonlocal_goto"
  [(use (match_operand 0 "general_operand"))
   (use (match_operand 1 "general_operand"))
   (use (match_operand 2 "general_operand"))
   (use (match_operand 3 "general_operand"))]
  ""
{
  cdp1802_expand_nonlocal_goto (operands[0], operands[1], operands[2], operands[3]);
  DONE;
})

;; ::::::::::::::::::::
;; ::
;; :: Prologue and Epilogue instructions
;; ::
;; ::::::::::::::::::::

(define_expand "prologue"
  [(const_int 0)]
  ""
  {
    cdp1802_expand_prologue ();
    DONE;
  })

(define_expand "epilogue"
  [(const_int 0)]
  ""
  {
    cdp1802_expand_epilogue (false);
    DONE;
  })

(define_expand "sibcall_epilogue"
  [(const_int 0)]
  ""
  {
    cdp1802_expand_epilogue (true);
    DONE;
  })

;; ::::::::::::::::::::
;; ::
;; :: Miscellaneous instructions
;; ::
;; ::::::::::::::::::::

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "1")])

(define_insn "blockage"
  [(unspec_volatile [(const_int 0)] 0)]
  ""
  ""
  [(set_attr "length" "0")])
